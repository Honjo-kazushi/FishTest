<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ダイビング魚データベース</title>
  <link rel="stylesheet" href="./css/style.css">
</head>
<body>
  <div class="container">
    <div class="left-panel">
    <!-- ── ①魚ヘッダーを横並びに統合 ── -->
    <div class="fish-header">
      <img id="fishIcon" src="" alt="魚アイコン" />
      <div class="fish-info">
        <h2>
        <span id="fishName">魚の名前</span>
        </h2>
        <p>
          <span id="fishEnglish">英名</span> |
          <span id="fishFamily">魚の仲間</span>
        </p>
      </div>
    </div>

    <div class="fish-feature">
      <strong>特徴:</strong>
        <div id="fishFeature" class="feature-text"></div>
    </div>

    <!-- ── フィルターパネル（仮レイアウト） -->
    <div class="filter-panel small">
      <!-- カナ行ボタン -->
      <div class="kana-buttons">
        <button data-kana="あ">あ</button>
        <button data-kana="か">か</button>
        <button data-kana="さ">さ</button>
        <button data-kana="た">た</button>
        <button data-kana="な">な</button>
        <button data-kana="は">は</button>
        <button data-kana="ま">ま</button>
        <button data-kana="や">や</button>
        <button data-kana="ら">ら</button>
        <button data-kana="わ">わ</button>
        <button data-kana="全">全</button>
      </div>
      
      <!-- フィルターセレクトボックス -->
      <div id="filters">
        <span class="select-clear-wrapper">
          <select id="fishSelect" class="selectpicker">
           <option value="">魚を選択</option>
          </select>
           <button type="button" class="clear-btn" data-target="fishSelect">C</button>  
        </span>
        <span class="select-clear-wrapper">
          <select id="placeSelect">
           <option value="">場所を選択</option>
          </select>
           <button type="button" class="clear-btn" data-target="placeSelect">C</button>
        </span>
        <span class="select-clear-wrapper">
          <select id="groupSelect">
           <option value="">仲間を選択</option>
          </select>
           <button type="button" class="clear-btn" data-target="groupSelect">C</button>
        </span>
      </div>
     </div>
    </div>
  <!-- ====== BEGIN: Audio Selection Modal ====== -->
  <div id="audioModal" class="modal" style="display:none;">
    <div class="modal-content">
      <h2>ようこそ FishPedia へ！</h2>
      <p>動画の音声をオンにしますか？</p>
      <button id="btnAudioOn">オンで開始</button>
      <button id="btnAudioOff">無音で続ける</button>
    </div>
  </div>
  <!-- ====== END: Audio Selection Modal ====== -->

  <div class="right-panel">

    <div id="playerContainer" style="position: relative;">
      <div id="player"></div>
      <img id="playerOverlay"
        src="/images/color/FishpediaTitle.png"
        alt="Fishpedia タイトルオーバーレイ"
        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; display: block; opacity: 1; z-index: 2; transition: opacity 0.3s ease;" />
    </div>

      <div class="controls" style="display: flex; align-items: center; gap: 0.5rem; padding: 10px; background: #e0f0f7; width: fit-content; margin-left: 1rem;">
  <!-- トグルスイッチ -->
  <label style="margin-right: 10px; display: inline-flex; align-items: center; gap: 0.5rem;">
    連続再生
    <input type="checkbox" id="repeatToggle" class="toggle-button" checked />
  </label>

  <button onclick="prevGroup()">前Gr</button>
  <button onclick="prevVideo()">前へ</button>
  <button onclick="pauseVideo()">ポーズ</button>
  <button onclick="stopVideo()">停止</button>
  <button onclick="playVideo()">再生</button>
  <button onclick="nextVideo()">次へ</button>
  <button onclick="nextGroup()">次Gr</button>
  </div>
      <div class="video-meta">
        <div><strong>場所:</strong> <span id="videoPlace"></span></div>
        <div><strong>年:</strong> <span id="videoYear"></span></div>
        <div><strong>ファイル:</strong> <span id="videoFile"></span></div>
      </div>
    </div>

  </div>
  <div class="icon-bar" id="iconBar"></div>
 </div>
</div>

</body>

<script src="./js/fishesData.js"></script>
<script src="./js/videosData.js"></script> 
<script src="./js/groupsData.js"></script>
<script src="./js/placesData.js"></script>

<script>
const MAX_GROUP = 56;
const BASE_API_URL = "https://script.google.com/macros/s/AKfycbx9xS8N0HadBqim2MdMsW-G2HfjJ-hyMzGmSsvOuRlZx1fCJayqMJPsmbRiIcVzUSoX_g/exec";
    
// YouTube Player オブジェクト用
window.ytPlayer = null;
// ★追加：グループの動画一覧を静的データから取得（なければGASにフォールバック）
async function listVideosByGroup(groupId) {
  // 最速：VIDEOS_BY_FISH（FishID→配列）から合成（すでに並び済み）
  if (typeof VIDEOS_BY_FISH === 'object' && VIDEOS_BY_FISH) {
    const fishIds = FISHES.filter(f => f.GroupID === Number(groupId)).map(f => String(f.FishID));
    const out = [];
    for (const fid of fishIds) {
      const arr = VIDEOS_BY_FISH[fid];
      if (arr && arr.length) out.push(...arr);
    }
    return out;
  }
  // 次点：フラット配列 VIDEOS からフィルタ
  if (Array.isArray(VIDEOS) && VIDEOS.length) {
    return VIDEOS.filter(v => Number(v.GroupID) === Number(groupId));
  }
  // 最後の保険：GAS
  return fetch(`${BASE_API_URL}?action=listVideosByGroup&groupId=${groupId}`).then(r => r.json());
}

let fishes = [], videos = [];
let currentGroupId = 0;
let repeatMode = true;
let videoIds = [];
let ytPlayer;
let currentIndex = 0;
let lastPlayerState = null;
let isGroupFixed = false;    // 手動でグループ選択されたら true

// 現在の選択文字（""なら全表示）
let currentLetter = "";

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

async function initData() {

  // 魚データは静的モジュールから即時取得
  fishes = FISHES;
  // 2) グループ一覧を取得してドロップダウンに反映
  // グループ一覧は静的配列から即時取得
  populateGroupSelect(GROUPS);
  // 3) 五十音ボタンを初期化
  setupKanaButtons(fishes);
  // 4) 撮影場所一覧を取得してドロップダウンに反映
  populatePlaceSelect(PLACES);
  // 5) 魚選択ドロップダウンに全件表示 
  populateFishSelect(fishes);
  // 6) 乱数で初期グループIDを決定・セット
  // ① groupsSequence の先頭＋中身＋末尾を準備
  // （起動時に一度だけシャッフルしておけば以降は変わらない）
  const OPENING_GROUP_ID = 999;
  // ① 静的データから動画のあるグループID集合を作成
  //    VIDEOS は videosData.js で定義されている全エントリの配列
  const availableGroupIds = new Set(VIDEOS.map(v => Number(v.GroupID)));  // :contentReference[oaicite:0]{index=0}
  // ② 除外する固定IDだけ絞り込み、それ以外はすべて動画ありでフィルタ
  const otherIds = GROUPS
    .map(g => g.groupId)
    .filter(id =>
      id !== OPENING_GROUP_ID &&  // 先頭固定
      id !== 50 &&                // ダイジェスト
      id !== 39 &&                // 不明
      availableGroupIds.has(id)   // 動画データあり
    );

  // ③ Fisher–Yates でシャッフル
    for (let i = otherIds.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [otherIds[i], otherIds[j]] = [otherIds[j], otherIds[i]];
    }
    groupSequence = [OPENING_GROUP_ID, ...otherIds, 50, 39];
    sequenceIndex = 0;
  // ② その後は従来の魚データ取得・UI描画…
  const initialGroup = groupSequence[sequenceIndex];
    currentGroupId = initialGroup;// …fetchして videos, videoIds を作る…
      
    videos = await listVideosByGroup(initialGroup);
  // 【フォールバック】動画がゼロ件なら次のグループを自動で探す
    if (videos.length === 0 && initialGroup !== OPENING_GROUP_ID) {
        console.warn('[initData] no videos for group', initialGroup);
      for (let gid = 1; gid <= MAX_GROUP; gid++) {
        if (gid === initialGroup) continue;
          const tmp = await listVideosByGroup(gid); // 追加 9/15：静的データから取得
          if (tmp.length) {
            currentGroupId = gid;
            videos = tmp;
            console.info('[initData] switched to group', gid, ' videos.length=', tmp.length);
            break;
          }
        }
      }
  // 8) アイコンバーを描画（groupSelect の change でも同じ処理を呼び出します）
    renderIconBar("next");
      
  // ── 追加: Cボタンで該当セレクトをクリア ──
    document.querySelectorAll('.clear-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const targetId = btn.dataset.target;
        const sel = document.getElementById(targetId);
        sel.value = '';                     // 選択解除
        // 2) グループ選択以外はこれまでどおり change を飛ばす
        if (targetId !== 'groupSelect') {
          sel.dispatchEvent(new Event('change')); // change イベントを発火
        }
      });
    });
    
  // ── 追加: fishSelect変更時にGroupとPlaceをクリア ──
    const fishSel = document.getElementById('fishSelect');
    fishSel.addEventListener('change', () => {
      document.getElementById('groupSelect').value = '';
      document.getElementById('placeSelect').value = '';
    // 必要に応じてUI更新／動画の再キュー処理をここで呼び出し
    });
    
    // トグル初期化はここで
    const toggle = document.getElementById("repeatToggle");
    repeatMode = toggle.checked;
    toggle.addEventListener("change", () => {
    repeatMode = toggle.checked;
    });

    // 初期表示：選択中のグループの先頭魚情報を取得
    const selectedGroup = currentGroupId;
    const groupVideos = videos.filter(v => {
    const fish = fishes.find(f => f.FishID === v.FishID);
    return fish && fish.GroupID === selectedGroup;
  });
    if (groupVideos.length > 0) {
      const firstFishId = groupVideos[0].FishID;
      const firstFish   = fishes.find(f => f.FishID === firstFishId);
      const firstVideo  = groupVideos[0];
    // 情報表示
      updateFishInfo(firstFish);
      updateVideoMeta(firstVideo);
      
     
    // ガード：loadVideoById の直前に置く
    if (!window.ytPlayer || typeof window.ytPlayer.loadVideoById !== 'function') {
      console.warn('[initData] ytPlayer not ready, retrying in 100ms');
      setTimeout(initData, 100);
      return;
    }

    // 必要に応じて自動再生したい場合は以下をアンコメント
    // playVideoByFish(entry.fishId, entry.videoId);
    // 動画を「セットだけ」ではなく、そのまま再生したい場合
      const vid = extractVideoId(firstVideo.YouTubeURL);
      window.ytPlayer.loadVideoById(vid);
      window.ytPlayer.playVideo();
    }
}

document.addEventListener('DOMContentLoaded', initData);

// ひらがな→カタカナ変換ヘルパー
function toKatakana(ch) {
  const code = ch.charCodeAt(0);
  // ひらがな範囲(ぁ=0x3041～ゖ=0x3096)のみ変換
  if (code >= 0x3041 && code <= 0x3096) {
    return String.fromCharCode(code + 0x60);
  }
  return ch;
}

/*
* カナ行ボタンにクリックハンドラを登録し、
* 押された文字で fishes 配列を絞り込んで
* 魚ドロップダウンを再描画する
*/

// ひらがなボタン→対象カタカナ文字群マップ
const KANA_MAP = {
  "あ": ["ア","イ","ウ","エ","オ"],
  "か": ["カ","キ","ク","ケ","コ"],
  "さ": ["サ","シ","ス","セ","ソ"],
  "た": ["タ","チ","ツ","テ","ト"],
  "な": ["ナ","ニ","ヌ","ネ","ノ"],
  "は": ["ハ","ヒ","フ","ヘ","ホ"],
  "ま": ["マ","ミ","ム","メ","モ"],
  "や": ["ヤ","ユ","ヨ"],
  "ら": ["ラ","リ","ル","レ","ロ"],
  "わ": ["ワ","ヲ"],
  "全": null  // 全件は special case
};

function setupKanaButtons(fishes) {
  const buttons = document.querySelectorAll('.kana-buttons button[data-kana]');
  buttons.forEach(btn => {
    btn.addEventListener('click', () => {
      const kana = btn.dataset.kana;

      // 同ボタン連打は無視
      if (kana !== '全' && btn.classList.contains('active')) return;
      // まず全ボタンの active をクリア
      buttons.forEach(b => b.classList.remove('active'));

      if (kana === '全') {
        // 全押し：全件表示
        populateFishSelect(fishes);
      } else {
        // 特定行押し：そのボタンだけ active にして絞り込み
        btn.classList.add('active');
        const targets = KANA_MAP[kana];
        const filtered = fishes.filter(f => targets.includes(f.Name.charAt(0)));
        populateFishSelect(filtered);
      }
    });
  });
}



/**
* グループセレクトボックスを初期化する
* @param {Array<{groupId: number, nameJp: string}>} allGroups
*/
function populateGroupSelect(allGroups) {

  // 1) セレクト要素を取得
  const sel = document.getElementById('groupSelect');
  // 2) 既存の<option>をクリアして、デフォルト「全グループ」を追加
  sel.innerHTML = '<option value="">全グループ</option>';
  // ── ① 静的データから「動画のある」グループID集合を作る
  const availableGroupIds = new Set(VIDEOS.map(v => Number(v.GroupID)));
  // 「不明」と「ダイジェスト」を切り出す
  const unknownGroup  = allGroups.find(g => g.nameJp === '不明');
  const digestGroup   = allGroups.find(g => g.nameJp === 'ダイジェスト');
  // ── ② 「不明／ダイジェスト」を除き、かつ動画ありのグループだけ抽出
  const otherGroups = allGroups.filter(g =>
    g.nameJp !== '不明' &&
    g.nameJp !== 'ダイジェスト' &&
    availableGroupIds.has(g.groupId)
  );
      
  // 他のグループを五十音でソートして追加
  otherGroups
    .sort((a, b) => a.nameJp.localeCompare(b.nameJp, 'ja'))
    .forEach(g => {
      const opt = document.createElement('option');
      opt.value       = g.groupId;
      opt.textContent = g.nameJp;
      sel.appendChild(opt);
    });
  // 「不明」があれば追加
  if (unknownGroup) {
    const opt = document.createElement('option');
    opt.value       = unknownGroup.groupId;
    opt.textContent = unknownGroup.nameJp;
    sel.appendChild(opt);
  }
  // 「ダイジェスト」があれば追加
  if (digestGroup) {
    const opt = document.createElement('option');
    opt.value       = digestGroup.groupId;
    opt.textContent = digestGroup.nameJp;
    sel.appendChild(opt);
  }

  sel.addEventListener('change', async (e) => {
  // 手動グループ選択時は fishSelect をクリア
    document.getElementById('fishSelect').value = '';
    currentGroupId = Number(e.target.value);
    // 新グループの動画リスト取得
    videos = await listVideosByGroup(currentGroupId); // 追加 9/15：静的データから取得
    // 動画キューを必ず更新
    videoIds = videos.map(v => ({
      videoId: extractVideoId(v.YouTubeURL),
      fishId:  v.FishID
     }));

    currentIndex = 0;
    renderIconBar("next");
    isGroupFixed = false;  //仕様変更：グループがコンボで選ばれたら、頭出しのみの機能とする
    // 先頭動画を再生
    currentIndex = 0;
    const entry = videoIds[0];
    if (entry) {
      const vid   = entry.videoId;
      if (repeatMode && vid) {
        window.ytPlayer.loadVideoById(vid);
        window.ytPlayer.playVideo();
      } else {
        window.ytPlayer.cueVideoById(vid);               
      }
      // 表示情報の更新
      const fishMeta = fishes.find(f => f.FishID === entry.fishId);
      if (fishMeta) updateFishInfo(fishMeta);
        const meta = videos.find(v => extractVideoId(v.YouTubeURL) === entry.videoId);
        if (meta) updateVideoMeta(meta);
      }
    });
}
        
  
function populatePlaceSelect(list) {
  const sel = document.getElementById('placeSelect');
  sel.innerHTML = '<option value="">全場所</option>';
  list.forEach(p => {
    const opt = document.createElement('option');
      opt.value = p;
      opt.textContent = p;
      sel.appendChild(opt);
    });
    // 変更→アイコンバー再描画
    sel.addEventListener('change', () => {
    // 【追加】Place変更時は fishSelect をクリア
      const fishSel = document.getElementById('fishSelect');
      fishSel.value = '';
      renderIconBar("next");
    });
  }

function populateFishSelect(list) {
  const sel = document.getElementById('fishSelect');
  sel.innerHTML = '';
  list.sort((a, b) => a.Name.localeCompare(b.Name, 'ja'));
       
  // 先頭にダミーオプション（必要なら）
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = '— 魚を選択 —';
  sel.appendChild(placeholder);
      
  list.forEach(f => {
    const opt = document.createElement('option');
    opt.value = f.FishID;
    opt.textContent = f.Name;
    sel.appendChild(opt);
  });
    
  // ── 追加：魚選択 change 時の一連処理 ──
  let fishSel = document.getElementById('fishSelect');
  // 既存の匿名リスナは削除している想定
  fishSel.replaceWith(fishSel.cloneNode(true));
  fishSel = document.getElementById('fishSelect'); // 再代入
  fishSel.addEventListener('change', async e => {
  // 1) フィルタクリア
  document.getElementById('groupSelect').value = '';
  document.getElementById('placeSelect').value = '';
  // 2) 選択魚→グループ判定
  const fishId = Number(e.target.value);
  const fishObj = fishes.find(f => f.FishID === fishId);
  if (!fishObj) return;
    const groupId = fishObj.GroupID;
  // 3) グループが変わっていたら動画を再取得
    if (groupId !== currentGroupId) {
      currentGroupId = groupId;
      videos = await listVideosByGroup(groupId).catch(()=>[]);
      videoIds = videos.map(v => ({
      fishId:  v.FishID,
      videoId: extractVideoId(v.YouTubeURL)
      }));
    }
 
  // ── 魚選択時の頭出し位置設定 ──
  // 仕様変更：魚選択は頭だしのみの機能に変更　グループ全動画はそのまま保持し、currentIndex に対象魚の先頭動画をセット
  const idx = videoIds.findIndex(v => v.fishId === fishId);
  currentIndex = idx >= 0 ? idx : 0;
      
  // 4) アイコンバー再描画→メタ更新→再生 or キュー
  renderIconBar("next");
  updateFishInfo(fishObj);
  //仕様変更：魚選択は頭だしのみの機能に変更
  const entry = videoIds[currentIndex];
    if (entry) {
      const meta = videos.find(v =>
        extractVideoId(v.YouTubeURL) === entry.videoId
        );
      if (repeatMode) {
        window.ytPlayer.loadVideoById(entry.videoId);
        window.ytPlayer.playVideo();
      } else {
        window.ytPlayer.cueVideoById(entry.videoId);
      }
      if (meta) updateVideoMeta(meta);
    }
  //仕様変更：魚選択は頭だしだけの機能に変更
    isGroupFixed = false;
    });
}

function onGroupChange(e) {
  const gid = e.target.value;
  // groupId で絞った魚一覧を再表示
  const filtered = gid ? Fishes.filter(f=>f.GroupID==gid) : Fishes;
  populateFishSelect(filtered);
}

function onPlaceChange(e) {
  const place = e.target.value;
  document.querySelectorAll('.fish-icon').forEach(img => {
  // ① data-fish-id 属性から ID を取得
  const fid = Number(img.dataset.fishId);

  // ② その魚の動画リストの中に該当場所があるか調べる
  const hasAtPlace = videos.some(v =>
    v.FishID === fid && v.撮影場所 === place
  );

  // ③ fishes マスタを参照してカラー／グレイを切り替え
  const fishMeta = fishes.find(f => f.FishID === fid);
    if (fishMeta) {
      img.src = hasAtPlace
        ? fishMeta.IconURL
        : fishMeta.IconInactiveURL;
      }
    });
}    

function onYouTubeIframeAPIReady() {
  window.ytPlayer = new YT.Player("player", {
    height: "360",
    width: "640",

    playerVars: {
      /*デプロイしたとき、本チャンでは無音でないと自動再生しない */
      autoplay: 1,     // 自動再生要求（ポリシー判定用）
      mute: 1,         // ミュート指定
      playsinline: 1,  // iOSでインライン再生
    
      controls:        0,  // コントロールバー非表示
      disablekb:       1,  // キーボード操作無効化
      modestbranding:  1,  // ロゴ最小表示
      rel:             0,  // 関連動画非表示
      fs:              0,  // フルスクリーンボタン非表示
      iv_load_policy:  3,  // アノテーション非表示
      enablejsapi:     1,
      origin:          window.location.origin,   

  },
    // 停止時にオーバーレイ制御を行う
  events: {
    onStateChange: onPlayerStateChange,
  },
});
}

/**
 * #iconBar 内に魚アイコンを並べる(名前、撮影年、場所順)
 * - videos: 現在のグループの動画リスト（FishID, YouTubeURL,... の配列）
 * - fishes: 全魚メタデータ（FishID, Name, IconURL,... の配列）
 */
/**
 * アイコンバー描画＋場所フィルタ後のグループスキップ
 * @param {"next"|"prev"} direction - スキップ方向
 */
function renderIconBar(direction) {
//function renderIconBar() {
  const bar = document.getElementById('iconBar');
  bar.innerHTML = '';           // 一旦クリア
  const selectedPlace = document.getElementById('placeSelect').value;

  // 1) アイコン表示用に、Group 内の魚IDをあーわ順で並べ替え
  // videos が undefined でも空配列にフォールバック
  const safeVideos = Array.isArray(videos) ? videos : [];
  // undefined や null を除外して FishID を抽出
  const fishIds = Array.from(
    new Set(
      safeVideos
        .filter(v => v != null && typeof v.FishID !== 'undefined')
        .map(v => v.FishID)
    )
  );

  const sortedFishIds = fishIds
    .map(id => fishes.find(f => f.FishID === id))
    .sort((a, b) => a.Name.localeCompare(b.Name, 'ja'))
    .map(f => f.FishID)

  sortedFishIds.forEach(fid => {
    const fish = fishes.find(f => f.FishID === fid);
    if (!fish) return;

    const wrapper = document.createElement('div');
    wrapper.classList.add('fish-icon-wrapper');

    const img = document.createElement('img');
    img.dataset.fishId = fid;
    // 選択場所があれば、その魚に該当場所の動画があるかで色／グレーを切り替え
    const atPlace = selectedPlace
      ? videos.some(v => v.FishID === fid && v.撮影場所 === selectedPlace)
      : true;
    img.src = atPlace ? fish.IconURL : fish.IconInactiveURL;
    img.alt = fish.Name;
    img.classList.add('fish-icon');

    img.addEventListener('click', () => {

    const fishSel = document.getElementById('fishSelect');
    const selectedFish = fishSel.value;
    const place = document.getElementById('placeSelect').value;
    // 魚未選択かつ場所フィルタで非該当（灰色）の場合は無視
    if (!selectedFish && place && entry.撮影場所 !== place) return;
    // fishSelect にセットして change 発火
    fishSel.value = fid;
    fishSel.dispatchEvent(new Event('change'));
    });
    wrapper.appendChild(img);

    // 魚名ラベル
    const label = document.createElement('div');
    label.classList.add('fish-label');
    label.textContent = fish.Name;
    wrapper.appendChild(label);

    // バーに追加
    bar.appendChild(wrapper);

  });

   if (!document.getElementById('fishSelect').value) {

      // 場所フィルタ：選択があればその場所の動画のみ、なければ次グループか前グループへ
      const sel = document.getElementById('placeSelect').value;
      const filteredVideos = sel
        ? videos.filter(v => v.撮影場所 === sel)
        : videos.slice();
      
      if (sel && filteredVideos.length === 0) {
       console.warn('[renderIconBar] no videos at place, skipping', currentGroupId);
       return direction === 'prev' ? prevGroup() : nextGroup();
      }

      const sortedVideos = filteredVideos.slice().sort((a, b) => {
//    const sortedVideos = videos.slice().sort((a, b) => {
       // 1) 魚名（あーわ順）
       const fa = fishes.find(f => f.FishID === a.FishID);
       const fb = fishes.find(f => f.FishID === b.FishID);
       let cmp = fa.Name.localeCompare(fb.Name, 'ja');
       if (cmp !== 0) return cmp;
       // 2) 同じ魚なら撮影年（数値昇順）
       cmp = Number(a.撮影年) - Number(b.撮影年);
       if (cmp !== 0) return cmp;
       // 3) 撮影場所（PLACES 配列の順序）
       const idxA = PLACES.indexOf(a.撮影場所);
       const idxB = PLACES.indexOf(b.撮影場所);
       return idxA - idxB;
    });
     videoIds = sortedVideos.map(v => ({
       fishId: v.FishID,
       videoId: extractVideoId(v.YouTubeURL)
    }));
  }
 }
 
function getRandomGroupId() {
  return Math.floor(Math.random() * MAX_GROUP) + 1;
}

function extractVideoId(url) {
  const match = url?.match(/(?:youtu\.be\/|youtube\.com\/(?:watch\?v=|embed\/))([a-zA-Z0-9_-]{11})/);
  return match ? match[1] : "";
}

function updateFishInfo(fish) {
  document.getElementById("fishName").textContent = fish.Name;
  document.getElementById("fishEnglish").textContent = fish.英名 || "";
  document.getElementById("fishFamily").textContent = fish["魚の仲間"] || "";
  document.getElementById("fishFeature").textContent = fish.特徴 || "";
  document.getElementById("fishIcon").src = fish.IconURL;
}

function updateVideoMeta(video) {
  document.getElementById("videoPlace").textContent = video.撮影場所 || "";
  document.getElementById("videoYear").textContent = video.撮影年 || "";
  document.getElementById("videoFile").textContent = video.動画ファイル名 || "";
}

// — モーダル要素を取得 —
const audioModal = document.getElementById('audioModal');
const btnOn  = document.getElementById('btnAudioOn');
const btnOff = document.getElementById('btnAudioOff');

// モーダルを表示する関数
function showAudioModal() {
  return new Promise(resolve => {
    audioModal.style.display = 'flex';
    const clean = () => {
      audioModal.style.display = 'none';
      btnOn.removeEventListener('click', onOn);
      btnOff.removeEventListener('click', onOff);
    };
    const onOn = () => { clean(); resolve('on'); };
    const onOff = () => { clean(); resolve('off'); };
    btnOn.addEventListener('click', onOn);
    btnOff.addEventListener('click', onOff);
  });
}


/**
 * fishId の動画を再生またはキューに登録し、情報更新も行う
 * @param {number} fishId
 * @param {string} videoId
 * @param {boolean} play  再生モードなら true（load）、falseなら cue
 */
function playVideoByFish(fishId, videoId) {
  console.log('[playVideoByFish] called with', { fishId, videoId });
  const fish = fishes.find(f => f.FishID === fishId);
   // find the specific video record
  const video = videos.find(v =>
    v.FishID === fishId &&
    extractVideoId(v.YouTubeURL) === videoId
  );
  // determine the index within videoIds
  const entryIndex = videoIds.findIndex(v =>
    v.fishId === fishId && v.videoId === videoId
  );
  if (entryIndex !== -1 && video) {
    currentIndex = entryIndex;
    // load and play the exact video
    if (repeatMode) {
      window.ytPlayer.loadVideoById(videoId);
      window.ytPlayer.playVideo();
    } else {
      window.ytPlayer.cueVideoById(videoId);
    }
        
    document.getElementById("playerOverlay").style.display = "none";
    document.getElementById("playerOverlay").style.opacity = "0";
    updateFishInfo(fish);
    updateVideoMeta(video);
  }
}

let lastState = null;
  
/**
 * YouTube プレイヤーの状態が変化したときに呼ばれる
 */
function onPlayerStateChange(event) {
  const overlay = document.getElementById("playerOverlay");

  // ── 通常ステートハンドリング ──
  switch (event.data) {
    case YT.PlayerState.ENDED:

    // ── 先にガードしておく ──
      if (!videoIds[currentIndex]) {
        console.warn('no entry at index', currentIndex, 'queue=', videoIds);
        return;
      }
     // 再生終了時の連続再生処理
      if (repeatMode) {
        if (currentIndex < videoIds.length - 1) {
          // 同グループ内の次動画へ
          nextVideo();
        } else {
          // ── 手動選択時固定モードなら同グループ頭に戻す ──
          if (isGroupFixed) {
              currentIndex = 0;
              const entry0 = videoIds[0];
              playVideoByFish(entry0.fishId, entry0.videoId);
            } else {
              if (currentGroupId === OPENING_GROUP_ID) {
              // 通常モード：次グループへ
                nextGroup();
              // ２）モーダルだけ表示してユーザーに選択を促す

              const playerInstance = event.target;
              showAudioModal().then(choice => {
                if (choice === 'on') {
                  if (playerInstance.getPlayerState() === YT.PlayerState.PLAYING) {
                    playerInstance.pauseVideo();
                  }
                  playerInstance.unMute();               // ミュート解除フラグ
                  //playerInstance.setVolume(100);         // ボリューム最大（任意）
                  // 再度再生命令を出す
                  playerInstance.playVideo();    
                } else {
                  playerInstance.mute();                 // 無音継続
                }
              });                
              } else {
              // 通常モード：次グループへ
                nextGroup();
              }  
            }
        }
      } else {
        // repeatMode OFF → オーバーレイ表示のみ
        overlay.style.display = 'block';
        overlay.style.opacity = '1';
      }
      break;

    case YT.PlayerState.PLAYING:
      // 再生開始 → オーバーレイを隠す
      overlay.style.display = 'none';
      overlay.style.opacity = '0';
      // ── 追加：再生開始時にメタ情報を更新 ──
      // currentIndex は現在再生中のインデックス
      const entry = videoIds[currentIndex];
      // fishes と videos はグローバル変数
      const fish  = fishes.find(f => f.FishID === entry.fishId);
      const video = videos.find(v =>
        v.FishID === entry.fishId &&
        extractVideoId(v.YouTubeURL) === entry.videoId
      );
      if (fish && video) {
        updateFishInfo(fish);
        updateVideoMeta(video);
      }
      break;

    case YT.PlayerState.UNSTARTED:
      // 強制停止やリセットなどを検知
      if (
        lastPlayerState === YT.PlayerState.PLAYING ||
        lastPlayerState === YT.PlayerState.PAUSED
      ) {
        overlay.style.display = 'block';
        overlay.style.opacity = '1';
      }
      break;

    // 必要に応じて PAUSED, BUFFERING 等も追加可能
  }

  // 状態を記録
  lastPlayerState = event.data;
}


function playVideo() {window.ytPlayer.playVideo(); }
function pauseVideo() { window.ytPlayer.pauseVideo(); }
function stopVideo() { window.ytPlayer.stopVideo(); }

function nextVideo() {

  if (currentIndex < videoIds.length - 1) {
    // 同グループ内の次動画へ
    currentIndex++;
    const entry = videoIds[currentIndex];
    console.log('[nextVideo] playing entry', entry);

  // ▶️ load→play フローに委譲
    playVideoByFish(entry.fishId, entry.videoId);
  
  } else {
  // グループ末尾 → 次グループへ移行（再生せずキューのみ）
    nextGroup();
  }
}

function prevVideo() {
  if (currentIndex > 0) {
    // 同グループ内の前動画へ
    currentIndex--;
    const entry = videoIds[currentIndex];
    // ▶️ 一括で再生＋UI更新を行う
    playVideoByFish(entry.fishId, entry.videoId);
    
  } else {
    // グループ先頭 → 前グループへ移行（再生せずキューのみ）
    prevGroup();
  }
}

async function nextGroup() {
// ■ グループ移動時にコンボボックスの選択をクリア
  document.getElementById('fishSelect').value = '';
  document.getElementById('groupSelect').value = '';

// 「次グループ再生」が呼ばれたらグループ固定モードを解除
  isGroupFixed = false;

  sequenceIndex++;
  if (sequenceIndex >= groupSequence.length) {
    // オープニングを飛ばして、乱数グループの先頭から再開
    sequenceIndex = 1;
  }  
  currentGroupId = groupSequence[sequenceIndex];
      
    // 2) 新グループの動画を取得し、videoIds を再生成
  try {
    videos = await listVideosByGroup(currentGroupId);
    
    videoIds = videos.map(v => ({
      fishId:  v.FishID,
      videoId: extractVideoId(v.YouTubeURL)
    }));
    currentIndex = 0;

    // 3) アイコンバーを再描画
    renderIconBar("next");
    // 4) 先頭動画を load→play もしくは cue    
    if (videoIds.length > 0) {
      const entry = videoIds[0];
      const fish  = fishes.find(f => f.FishID === entry.fishId);
      const video = videos.find(v =>
        v.FishID === entry.fishId &&
        extractVideoId(v.YouTubeURL) === entry.videoId
        );
        updateFishInfo(fish);
        updateVideoMeta(video);
        
      // repeatMode フラグで再生 or キューを振り分け
      if (repeatMode) {
      // グループ最初の動画を読み込んで再生
        const vid = entry.videoId;
        if (vid) {
          window.ytPlayer.loadVideoById(vid);
          window.ytPlayer.playVideo();
        }
      } else {
      // 再生せずキューだけ
        const vid = entry.videoId;
        if (vid) {
          window.ytPlayer.cueVideoById(vid);
        }
      }
    }
  } catch (err) {
    console.error('[nextGroup] Error:', err);
    videos = [];
  }
}


async function prevGroup() {

// ■ グループ移動時にコンボボックスの選択をクリア
  document.getElementById('fishSelect').value = '';
  document.getElementById('groupSelect').value = '';

  // 1) グループIDをデクリメント（1 より小さければ MAX_GROUP に戻す）
  sequenceIndex--;
  if (sequenceIndex < 1) {
  // 先頭(オープニング＝index 0)の手前は
  // 末尾（乱数グループ最後、ダイジェスト/不明含む）に飛ばす
  sequenceIndex = groupSequence.length - 1;
  }
  currentGroupId = groupSequence[sequenceIndex];
      
  // 2) 新しいグループの動画一覧を取得
  try {
    videos = await listVideosByGroup(currentGroupId);
    // ★ videoIds を最新化
    videoIds = videos.map(v => ({
      fishId:  v.FishID,
      videoId: extractVideoId(v.YouTubeURL)
    }));
    currentIndex = 0;
    // 3) アイコンバーを再描画
    renderIconBar("prev");
    // 4) ★nextGroup と同じ再生制御ブロック
    if (videoIds.length > 0) {
      const entry = videoIds[0];
    // UI 更新
      const fish  = fishes.find(f => f.FishID === entry.fishId);
      const video = videos.find(v =>
        v.FishID === entry.fishId &&
        extractVideoId(v.YouTubeURL) === entry.videoId
      );
      updateFishInfo(fish);
      updateVideoMeta(video);
      // repeatMode に応じて再生 or cue
      if (repeatMode) {
        window.ytPlayer.loadVideoById(entry.videoId);
        window.ytPlayer.playVideo();
      } else {
        window.ytPlayer.cueVideoById(entry.videoId);
      }
    }
  } catch (err) {
    console.error('[nextGroup] Error:', err);
    videos = [];
  }
}  

</script>
  

<script src="https://www.youtube.com/iframe_api"></script>

</body>
</html>
